name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  SCHEME: DataBar
  PRODUCT_NAME: DataBar

jobs:
  build-and-release:
    name: Build, Sign, Notarize and Release
    runs-on: macos-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

      - name: Xcode version
        run: xcodebuild -version

      - name: Extract version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version $VERSION"

      - name: Install Apple Developer ID Certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          MACOS_CI_KEYCHAIN_PWD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          
          echo -n "$MACOS_CERTIFICATE" | base64 --decode -i - -o "$CERTIFICATE_PATH"
          
          security create-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          security import "$CERTIFICATE_PATH" -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CI_KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          
          # Add to search list while preserving existing keychains
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychain -d user | tr -d '"')
          
          # Verify the identity is available
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

      - name: Resolve Swift packages
        run: xcodebuild -resolvePackageDependencies -scheme $SCHEME

      - name: Update version in project
        run: |
          cd DataBar.xcodeproj
          sed -i '' "s/MARKETING_VERSION = .*/MARKETING_VERSION = ${{ steps.version.outputs.version }};/g" project.pbxproj
          sed -i '' "s/CURRENT_PROJECT_VERSION = .*/CURRENT_PROJECT_VERSION = ${{ github.run_number }};/g" project.pbxproj

      - name: Build app
        run: |
          xcodebuild -scheme "$SCHEME" -configuration Release -derivedDataPath build \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

      - name: Codesign app bundle
        env:
          MACOS_CERTIFICATE_NAME: ${{ secrets.CODE_SIGN_IDENTITY }}
          MACOS_CI_KEYCHAIN_PWD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          APP_PATH="build/Build/Products/Release/$PRODUCT_NAME.app"
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          
          # Unlock keychain again (may have locked during build)
          security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          
          # Codesign Sparkle framework components (innermost to outermost)
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/XPCServices/Downloader.xpc"
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/XPCServices/Installer.xpc"
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Autoupdate"
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Updater.app"
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime "$APP_PATH/Contents/Frameworks/Sparkle.framework"
          
          # Codesign the main app bundle with entitlements
          /usr/bin/codesign --verbose -f -s "$MACOS_CERTIFICATE_NAME" --keychain "$KEYCHAIN_PATH" -o runtime --entitlements "DataBar/DataBar.entitlements" "$APP_PATH"
          
          # Verify
          /usr/bin/codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Create DMG
        env:
          MACOS_CERTIFICATE_NAME: ${{ secrets.CODE_SIGN_IDENTITY }}
        run: |
          APP_PATH="build/Build/Products/Release/$PRODUCT_NAME.app"
          
          npm install --global create-dmg
          create-dmg \
            --identity="$MACOS_CERTIFICATE_NAME" \
            "$APP_PATH" \
            ./ || true  # create-dmg returns non-zero if DMG already exists
          mv ./*.dmg "$PRODUCT_NAME.dmg" || true

      - name: Create zip
        run: |
          APP_PATH="build/Build/Products/Release/$PRODUCT_NAME.app"
          ditto -c -k --keepParent "$APP_PATH" "$PRODUCT_NAME.zip"

      - name: Notarize
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
        run: |
          APP_PATH="build/Build/Products/Release/$PRODUCT_NAME.app"
          
          # Write API key
          echo "$APPLE_API_KEY_BASE64" | base64 --decode > notarization_key.p8
          
          # Store credentials
          xcrun notarytool store-credentials "notarytool-profile" \
            --key notarization_key.p8 \
            --key-id "$APPLE_API_KEY_ID" \
            --issuer "$APPLE_API_ISSUER_ID"
          rm notarization_key.p8
          
          # Notarize the zip
          xcrun notarytool submit "$PRODUCT_NAME.zip" --keychain-profile "notarytool-profile" --wait
          
          # Staple
          xcrun stapler staple "$APP_PATH"
          
          # Notarize DMG if it exists
          if [ -f "$PRODUCT_NAME.dmg" ]; then
            xcrun notarytool submit "$PRODUCT_NAME.dmg" --keychain-profile "notarytool-profile" --wait
            xcrun stapler staple "$PRODUCT_NAME.dmg"
          fi

      - name: Recreate zip after stapling
        run: |
          APP_PATH="build/Build/Products/Release/$PRODUCT_NAME.app"
          rm -f "$PRODUCT_NAME.zip"
          ditto -c -k --keepParent "$APP_PATH" "$PRODUCT_NAME.zip"

      - name: Sign update with Sparkle
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          curl -L -o sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz
          mkdir -p sparkle_tools
          tar -xf sparkle.tar.xz -C sparkle_tools
          
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_key
          SIGN_OUTPUT=$(sparkle_tools/bin/sign_update "$PRODUCT_NAME.zip" --ed-key-file /tmp/sparkle_key)
          rm /tmp/sparkle_key
          
          # Extract just the signature value (sign_update outputs: sparkle:edSignature="..." length="...")
          ED_SIGNATURE=$(echo "$SIGN_OUTPUT" | grep -o 'sparkle:edSignature="[^"]*"' | sed 's/sparkle:edSignature="//' | sed 's/"$//')
          echo "ED_SIGNATURE=$ED_SIGNATURE" >> $GITHUB_ENV
          
          FILE_SIZE=$(stat -f%z "$PRODUCT_NAME.zip")
          echo "FILE_SIZE=$FILE_SIZE" >> $GITHUB_ENV

      - name: Generate release notes
        id: release_notes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [ -z "$PREVIOUS_TAG" ]; then
            # First release - get all commits
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
          fi
          
          # Start building release notes
          echo "## DataBar v${VERSION}" > release_notes.md
          echo "" >> release_notes.md
          echo "### Installation" >> release_notes.md
          echo "1. Download \`DataBar.zip\` below" >> release_notes.md
          echo "2. Unzip and move \`DataBar.app\` to your Applications folder" >> release_notes.md
          echo "3. Open the app (it's signed and notarized)" >> release_notes.md
          
          # Get merged PRs in this range
          PR_LIST=$(git log ${COMMIT_RANGE} --oneline --grep="Merge pull request" 2>/dev/null || echo "")
          
          if [ -n "$PR_LIST" ]; then
            echo "" >> release_notes.md
            echo "### Merged Pull Requests" >> release_notes.md
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                # Extract PR number from merge commit message
                PR_NUM=$(echo "$line" | grep -o '#[0-9]*' | head -1)
                if [ -n "$PR_NUM" ]; then
                  PR_NUMBER=${PR_NUM#\#}
                  # Get PR title using gh cli
                  PR_TITLE=$(gh pr view "$PR_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
                  if [ -n "$PR_TITLE" ]; then
                    echo "- ${PR_TITLE} ([${PR_NUM}](https://github.com/${{ github.repository }}/pull/${PR_NUMBER}))" >> release_notes.md
                  else
                    echo "- ${PR_NUM}" >> release_notes.md
                  fi
                fi
              fi
            done <<< "$PR_LIST"
          fi
          
          # Get commits (excluding merge commits)
          COMMIT_LIST=$(git log ${COMMIT_RANGE} --oneline --no-merges 2>/dev/null || echo "")
          
          if [ -n "$COMMIT_LIST" ]; then
            echo "" >> release_notes.md
            echo "### Commits" >> release_notes.md
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                COMMIT_SHA=$(echo "$line" | awk '{print $1}')
                COMMIT_MSG=$(echo "$line" | cut -d' ' -f2-)
                echo "- ${COMMIT_MSG} ([\`${COMMIT_SHA}\`](https://github.com/${{ github.repository }}/commit/${COMMIT_SHA}))" >> release_notes.md
              fi
            done <<< "$COMMIT_LIST"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: DataBar v${{ steps.version.outputs.version }}
          body_path: release_notes.md
          files: |
            DataBar.zip
            DataBar.dmg
          draft: false
          prerelease: false

      - name: Update appcast.xml
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DOWNLOAD_URL="https://github.com/sammarks/DataBar/releases/download/v${VERSION}/DataBar.zip"
          PUB_DATE=$(date -R)
          
          cat > appcast.xml << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>DataBar Updates</title>
              <link>https://github.com/sammarks/DataBar</link>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <pubDate>${PUB_DATE}</pubDate>
                <sparkle:version>${{ github.run_number }}</sparkle:version>
                <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>13.1</sparkle:minimumSystemVersion>
                <enclosure
                  url="${DOWNLOAD_URL}"
                  length="${FILE_SIZE}"
                  type="application/octet-stream"
                  sparkle:edSignature="${ED_SIGNATURE}"
                />
              </item>
            </channel>
          </rss>
          EOF

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git checkout main
          git add appcast.xml
          git commit -m "Update appcast.xml for v${VERSION}"
          git push origin main

      - name: Clean up keychain
        if: always()
        run: security delete-keychain "$RUNNER_TEMP/build.keychain-db" || true
