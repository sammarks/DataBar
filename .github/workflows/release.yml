name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  SCHEME: DataBar
  PRODUCT_NAME: DataBar

jobs:
  build-and-release:
    name: Build, Sign, Notarize and Release
    runs-on: macos-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

      - name: Show Xcode version
        run: xcodebuild -version

      - name: Extract version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version $VERSION"

      - name: Install Apple certificate and provisioning profile
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          
          # Allow codesign to access the key without UI prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Add keychain to search list (prepend to existing list, don't replace)
          security list-keychain -d user -s $KEYCHAIN_PATH $(security list-keychain -d user | tr -d '"')
          
          # Make it the default
          security default-keychain -s $KEYCHAIN_PATH
          
          # Verify the certificate is accessible
          echo "Verifying certificate..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH
          
          # Export keychain path for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

      - name: Resolve Swift packages
        run: xcodebuild -resolvePackageDependencies -scheme $SCHEME

      - name: Update version in project
        run: |
          cd DataBar.xcodeproj
          sed -i '' "s/MARKETING_VERSION = .*/MARKETING_VERSION = ${{ steps.version.outputs.version }};/g" project.pbxproj
          sed -i '' "s/CURRENT_PROJECT_VERSION = .*/CURRENT_PROJECT_VERSION = ${{ github.run_number }};/g" project.pbxproj

      - name: Build Release
        run: |
          # Archive without signing - we'll manually codesign after export
          xcodebuild archive \
            -scheme $SCHEME \
            -configuration Release \
            -archivePath build/$PRODUCT_NAME.xcarchive \
            -destination 'platform=macOS' \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

      - name: Export app
        run: |
          cat > ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>developer-id</string>
              <key>teamID</key>
              <string>${{ secrets.DEVELOPMENT_TEAM }}</string>
              <key>signingStyle</key>
              <string>manual</string>
              <key>signingCertificate</key>
              <string>Developer ID Application</string>
          </dict>
          </plist>
          EOF

          # Export will fail to sign properly, so we just copy the app
          mkdir -p build/export
          cp -R "build/$PRODUCT_NAME.xcarchive/Products/Applications/$PRODUCT_NAME.app" build/export/

      - name: Codesign app
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          APP_PATH="build/export/$PRODUCT_NAME.app"
          ENTITLEMENTS="DataBar/DataBar.entitlements"
          
          # Unlock keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Get the signing identity hash from the keychain
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | awk '{print $2}')
          
          if [ -z "$IDENTITY" ]; then
            echo "ERROR: No Developer ID Application identity found in keychain"
            security find-identity -v -p codesigning "$KEYCHAIN_PATH"
            exit 1
          fi
          
          echo "Using identity hash: $IDENTITY"
          
          # List what we're working with
          echo "=== Sparkle framework structure ==="
          find "$APP_PATH/Contents/Frameworks/Sparkle.framework" -type f -perm +111 2>/dev/null || true
          
          # Sign Sparkle framework - must sign from innermost to outermost
          # Reference: https://sparkle-project.org/documentation/sandboxing/#code-signing
          SPARKLE="$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B"
          
          echo "=== Signing Sparkle XPC services ==="
          # Sign XPC service executables first, then the bundles
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/XPCServices/Downloader.xpc/Contents/MacOS/Downloader"
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/XPCServices/Downloader.xpc"
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/XPCServices/Installer.xpc/Contents/MacOS/Installer"
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/XPCServices/Installer.xpc"
          
          echo "=== Signing Sparkle Updater app ==="
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/Updater.app/Contents/MacOS/Updater"
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/Updater.app"
          
          echo "=== Signing Sparkle Autoupdate executable ==="
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/Autoupdate"
          
          echo "=== Signing Sparkle main binary ==="
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$SPARKLE/Sparkle"
          
          echo "=== Signing Sparkle framework bundle ==="
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --sign "$IDENTITY" "$APP_PATH/Contents/Frameworks/Sparkle.framework"
          
          echo "=== Signing main app ==="
          codesign --force --timestamp --options runtime --keychain "$KEYCHAIN_PATH" --entitlements "$ENTITLEMENTS" --sign "$IDENTITY" "$APP_PATH"
          
          # Verify the signature
          echo "=== Verifying signature ==="
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"
          
          echo "=== Signature details ==="
          codesign -dv --verbose=4 "$APP_PATH"

      - name: Notarize app
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
        run: |
          cd build/export
          
          # Use ditto to create zip - preserves symlinks, resource forks, and HFS metadata
          # Regular zip breaks macOS framework signatures by following symlinks
          ditto -c -k --keepParent $PRODUCT_NAME.app $PRODUCT_NAME.zip

          # Write API key to file
          mkdir -p ~/.private_keys
          echo -n "$APPLE_API_KEY_BASE64" | base64 --decode > ~/.private_keys/AuthKey_${APPLE_API_KEY_ID}.p8

          # Submit and capture the submission ID
          SUBMIT_OUTPUT=$(xcrun notarytool submit $PRODUCT_NAME.zip \
            --key ~/.private_keys/AuthKey_${APPLE_API_KEY_ID}.p8 \
            --key-id "$APPLE_API_KEY_ID" \
            --issuer "$APPLE_API_ISSUER_ID" \
            --wait 2>&1)
          
          echo "$SUBMIT_OUTPUT"
          
          # Extract submission ID and check status
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o '[0-9a-f\-]\{36\}' | head -1)
          
          # Always fetch the log for debugging
          if [ -n "$SUBMISSION_ID" ]; then
            echo "Fetching notarization log for submission $SUBMISSION_ID..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --key ~/.private_keys/AuthKey_${APPLE_API_KEY_ID}.p8 \
              --key-id "$APPLE_API_KEY_ID" \
              --issuer "$APPLE_API_ISSUER_ID" \
              notarization-log.json || true
            cat notarization-log.json || true
          fi
          
          # Check if notarization was successful
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Invalid"; then
            echo "Notarization failed! See log above for details."
            exit 1
          fi

          xcrun stapler staple $PRODUCT_NAME.app

          # Clean up API key
          rm -rf ~/.private_keys

      - name: Create final zip for distribution
        run: |
          cd build/export
          rm -f $PRODUCT_NAME.zip
          # Use ditto to preserve symlinks and macOS metadata
          ditto -c -k --keepParent $PRODUCT_NAME.app $PRODUCT_NAME.zip

      - name: Sign update with Sparkle
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          cd build/export
          
          DERIVED_DATA=$(xcodebuild -showBuildSettings -scheme $SCHEME 2>/dev/null | grep -m1 BUILD_DIR | awk '{print $3}' | sed 's|/Build/Products||')
          SIGN_UPDATE="${DERIVED_DATA}/SourcePackages/artifacts/sparkle/Sparkle/bin/sign_update"
          
          if [ ! -f "$SIGN_UPDATE" ]; then
            SIGN_UPDATE=$(find ~/Library/Developer/Xcode/DerivedData -name "sign_update" -path "*/sparkle/*" 2>/dev/null | head -1)
          fi
          
          if [ -z "$SIGN_UPDATE" ] || [ ! -f "$SIGN_UPDATE" ]; then
            echo "sign_update not found, downloading Sparkle tools..."
            curl -L -o sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz
            mkdir -p sparkle_tools
            tar -xf sparkle.tar.xz -C sparkle_tools
            SIGN_UPDATE="sparkle_tools/bin/sign_update"
          fi
          
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_private_key
          SIGNATURE=$("$SIGN_UPDATE" $PRODUCT_NAME.zip --ed-key-file /tmp/sparkle_private_key)
          rm /tmp/sparkle_private_key
          
          echo "SPARKLE_SIGNATURE<<EOF" >> $GITHUB_ENV
          echo "$SIGNATURE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          FILE_SIZE=$(stat -f%z $PRODUCT_NAME.zip)
          echo "FILE_SIZE=$FILE_SIZE" >> $GITHUB_ENV

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          name: DataBar v${{ steps.version.outputs.version }}
          body: |
            ## DataBar v${{ steps.version.outputs.version }}
            
            ### Installation
            1. Download `DataBar.zip` below
            2. Unzip and move `DataBar.app` to your Applications folder
            3. Open the app (it's signed and notarized)
            
            ### What's New
            See the [CHANGELOG](https://github.com/sammarks/DataBar/blob/main/CHANGELOG.md) for details.
          files: build/export/DataBar.zip
          draft: false
          prerelease: false

      - name: Update appcast.xml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DOWNLOAD_URL="https://github.com/sammarks/DataBar/releases/download/v${VERSION}/DataBar.zip"
          PUB_DATE=$(date -R)
          
          cat > appcast.xml << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>DataBar Updates</title>
              <link>https://github.com/sammarks/DataBar</link>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <pubDate>${PUB_DATE}</pubDate>
                <sparkle:version>${{ github.run_number }}</sparkle:version>
                <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>13.1</sparkle:minimumSystemVersion>
                <enclosure
                  url="${DOWNLOAD_URL}"
                  length="${FILE_SIZE}"
                  type="application/octet-stream"
                  ${SPARKLE_SIGNATURE}
                />
              </item>
            </channel>
          </rss>
          EOF

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git checkout main
          git add appcast.xml
          git commit -m "Update appcast.xml for v${VERSION}"
          git push origin main

      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
